//! Terminal Colors Abstraction
//!
//! Provides 256 terminal colors abstraction, providing:
//! + Find best approximation to RGB color

/// Maximum possible quadrance of RGB colors with 8-bit per channel.
/// 
/// This quadrance is the in fact given by two opposite colors!.
const MAX_QUADRANCE: f64 = 3.0 * 255.0 * 255.0;

/// Abstraction for Terminal colors
///
/// Container of Terminal Color, for storing is RGB value
/// and it's color index.
#[derive(Debug)]
pub struct TermColor {
    /// Red channel
    pub r: u8,
    /// Green channel
    pub g: u8,
    /// Blue channel
    pub b: u8,
    /// Color Index
    ///
    /// As specified from <https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit>
    pub index: u8,
}

impl Default for TermColor {
    fn default() -> Self { Self { r: 0, g:0, b:0, index:0} }
}

impl TermColor {
    /// Create a TermColor from 24bit RGB color by finding the best approximate color in the 256 Terminal colors palette
    ///
    /// Find the terminal color that minimizes the asimilarity of a general RGB color
    /// by a exahustive calculation of quadrances, return the TermColor which minimizes the quadrance.
    pub fn from(r: u8, g:u8, b:u8) -> Self {
        let mut min = MAX_QUADRANCE;
        let mut tcolor = Self::default();
        tcolor.r = r;
        tcolor.g = g;
        tcolor.b = b;

        for (i, color) in TERM256_COLOR.iter().enumerate() {
            let mut termcolor = Self::default();
            termcolor.r = color.0;
            termcolor.g = color.1;
            termcolor.b = color.2;
            termcolor.index = i as u8;
            
            let q = tcolor.quadrance(&termcolor);

            if q < min {
                min = q;
                tcolor.index = i as u8;
            }
        }

        tcolor
    }

    /// Calculates the quadrance of two TermColors to measure similarity
    ///
    /// The quadrance is a quadratic measure to compare how similar two colors are
    /// and is defined by the sum of the squares of the differences of each channel
    /// when the two color are equal the quadrance is equal to zero,
    /// The biggest the quadrance can be is when comparing opposite colors (as white and black)
    /// and can be shown to be three times the maximum value of the channels,
    /// in this case each channels has an maximum equal to 255 thus the
    /// quadrance(white, black) = 3 * 255 * 255.
    pub fn quadrance(&self, tcolor: &TermColor) -> f64 {
        let q = f64::powi(self.r as f64 - tcolor.r as f64, 2) +
                f64::powi(self.g as f64 - tcolor.g as f64, 2) +
                f64::powi(self.b as f64 - tcolor.b as f64, 2);

        q
    }
}



/// Array of 256 Terminal Colors with their RGB (24-bit) equivalent,
/// ordered with the standard indexing
/* List generated by a custom script on the 6x6x6 cube color */
pub const TERM256_COLOR: [(u8, u8, u8); 256] = [
    (0x00, 0x00, 0x00),
    (0x80, 0x00, 0x00),
    (0x00, 0x80, 0x00),
    (0x80, 0x80, 0x00),
    (0x00, 0x00, 0x80),
    (0x80, 0x00, 0x80),
    (0x00, 0x80, 0x80),
    (0xC0, 0xC0, 0xC0),
    (0x80, 0x80, 0x80),
    (0xFF, 0x00, 0x00),
    (0xFF, 0xFF, 0x00),
    (0x00, 0xFF, 0x00),
    (0x00, 0x00, 0xFF),
    (0xFF, 0x00, 0xFF),
    (0x00, 0xFF, 0xFF),
    (0xFF, 0xFF, 0xFF),
    (0x00, 0x00, 0x00),
    (0x00, 0x00, 0x5F),
    (0x00, 0x00, 0x87),
    (0x00, 0x00, 0xAF),
    (0x00, 0x00, 0xD7),
    (0x00, 0x00, 0xFF),
    (0x00, 0x5F, 0x00),
    (0x00, 0x5F, 0x5F),
    (0x00, 0x5F, 0x87),
    (0x00, 0x5F, 0xAF),
    (0x00, 0x5F, 0xD7),
    (0x00, 0x5F, 0xFF),
    (0x00, 0x87, 0x00),
    (0x00, 0x87, 0x5F),
    (0x00, 0x87, 0x87),
    (0x00, 0x87, 0xAF),
    (0x00, 0x87, 0xD7),
    (0x00, 0x87, 0xFF),
    (0x00, 0xAF, 0x00),
    (0x00, 0xAF, 0x5F),
    (0x00, 0xAF, 0x87),
    (0x00, 0xAF, 0xAF),
    (0x00, 0xAF, 0xD7),
    (0x00, 0xAF, 0xFF),
    (0x00, 0xD7, 0x00),
    (0x00, 0xD7, 0x5F),
    (0x00, 0xD7, 0x87),
    (0x00, 0xD7, 0xAF),
    (0x00, 0xD7, 0xD7),
    (0x00, 0xD7, 0xFF),
    (0x00, 0xFF, 0x00),
    (0x00, 0xFF, 0x5F),
    (0x00, 0xFF, 0x87),
    (0x00, 0xFF, 0xAF),
    (0x00, 0xFF, 0xD7),
    (0x00, 0xFF, 0xFF),
    (0x5F, 0x00, 0x00),
    (0x5F, 0x00, 0x5F),
    (0x5F, 0x00, 0x87),
    (0x5F, 0x00, 0xAF),
    (0x5F, 0x00, 0xD7),
    (0x5F, 0x00, 0xFF),
    (0x5F, 0x5F, 0x00),
    (0x5F, 0x5F, 0x5F),
    (0x5F, 0x5F, 0x87),
    (0x5F, 0x5F, 0xAF),
    (0x5F, 0x5F, 0xD7),
    (0x5F, 0x5F, 0xFF),
    (0x5F, 0x87, 0x00),
    (0x5F, 0x87, 0x5F),
    (0x5F, 0x87, 0x87),
    (0x5F, 0x87, 0xAF),
    (0x5F, 0x87, 0xD7),
    (0x5F, 0x87, 0xFF),
    (0x5F, 0xAF, 0x00),
    (0x5F, 0xAF, 0x5F),
    (0x5F, 0xAF, 0x87),
    (0x5F, 0xAF, 0xAF),
    (0x5F, 0xAF, 0xD7),
    (0x5F, 0xAF, 0xFF),
    (0x5F, 0xD7, 0x00),
    (0x5F, 0xD7, 0x5F),
    (0x5F, 0xD7, 0x87),
    (0x5F, 0xD7, 0xAF),
    (0x5F, 0xD7, 0xD7),
    (0x5F, 0xD7, 0xFF),
    (0x5F, 0xFF, 0x00),
    (0x5F, 0xFF, 0x5F),
    (0x5F, 0xFF, 0x87),
    (0x5F, 0xFF, 0xAF),
    (0x5F, 0xFF, 0xD7),
    (0x5F, 0xFF, 0xFF),
    (0x87, 0x00, 0x00),
    (0x87, 0x00, 0x5F),
    (0x87, 0x00, 0x87),
    (0x87, 0x00, 0xAF),
    (0x87, 0x00, 0xD7),
    (0x87, 0x00, 0xFF),
    (0x87, 0x5F, 0x00),
    (0x87, 0x5F, 0x5F),
    (0x87, 0x5F, 0x87),
    (0x87, 0x5F, 0xAF),
    (0x87, 0x5F, 0xD7),
    (0x87, 0x5F, 0xFF),
    (0x87, 0x87, 0x00),
    (0x87, 0x87, 0x5F),
    (0x87, 0x87, 0x87),
    (0x87, 0x87, 0xAF),
    (0x87, 0x87, 0xD7),
    (0x87, 0x87, 0xFF),
    (0x87, 0xAF, 0x00),
    (0x87, 0xAF, 0x5F),
    (0x87, 0xAF, 0x87),
    (0x87, 0xAF, 0xAF),
    (0x87, 0xAF, 0xD7),
    (0x87, 0xAF, 0xFF),
    (0x87, 0xD7, 0x00),
    (0x87, 0xD7, 0x5F),
    (0x87, 0xD7, 0x87),
    (0x87, 0xD7, 0xAF),
    (0x87, 0xD7, 0xD7),
    (0x87, 0xD7, 0xFF),
    (0x87, 0xFF, 0x00),
    (0x87, 0xFF, 0x5F),
    (0x87, 0xFF, 0x87),
    (0x87, 0xFF, 0xAF),
    (0x87, 0xFF, 0xD7),
    (0x87, 0xFF, 0xFF),
    (0xAF, 0x00, 0x00),
    (0xAF, 0x00, 0x5F),
    (0xAF, 0x00, 0x87),
    (0xAF, 0x00, 0xAF),
    (0xAF, 0x00, 0xD7),
    (0xAF, 0x00, 0xFF),
    (0xAF, 0x5F, 0x00),
    (0xAF, 0x5F, 0x5F),
    (0xAF, 0x5F, 0x87),
    (0xAF, 0x5F, 0xAF),
    (0xAF, 0x5F, 0xD7),
    (0xAF, 0x5F, 0xFF),
    (0xAF, 0x87, 0x00),
    (0xAF, 0x87, 0x5F),
    (0xAF, 0x87, 0x87),
    (0xAF, 0x87, 0xAF),
    (0xAF, 0x87, 0xD7),
    (0xAF, 0x87, 0xFF),
    (0xAF, 0xAF, 0x00),
    (0xAF, 0xAF, 0x5F),
    (0xAF, 0xAF, 0x87),
    (0xAF, 0xAF, 0xAF),
    (0xAF, 0xAF, 0xD7),
    (0xAF, 0xAF, 0xFF),
    (0xAF, 0xD7, 0x00),
    (0xAF, 0xD7, 0x5F),
    (0xAF, 0xD7, 0x87),
    (0xAF, 0xD7, 0xAF),
    (0xAF, 0xD7, 0xD7),
    (0xAF, 0xD7, 0xFF),
    (0xAF, 0xFF, 0x00),
    (0xAF, 0xFF, 0x5F),
    (0xAF, 0xFF, 0x87),
    (0xAF, 0xFF, 0xAF),
    (0xAF, 0xFF, 0xD7),
    (0xAF, 0xFF, 0xFF),
    (0xD7, 0x00, 0x00),
    (0xD7, 0x00, 0x5F),
    (0xD7, 0x00, 0x87),
    (0xD7, 0x00, 0xAF),
    (0xD7, 0x00, 0xD7),
    (0xD7, 0x00, 0xFF),
    (0xD7, 0x5F, 0x00),
    (0xD7, 0x5F, 0x5F),
    (0xD7, 0x5F, 0x87),
    (0xD7, 0x5F, 0xAF),
    (0xD7, 0x5F, 0xD7),
    (0xD7, 0x5F, 0xFF),
    (0xD7, 0x87, 0x00),
    (0xD7, 0x87, 0x5F),
    (0xD7, 0x87, 0x87),
    (0xD7, 0x87, 0xAF),
    (0xD7, 0x87, 0xD7),
    (0xD7, 0x87, 0xFF),
    (0xD7, 0xAF, 0x00),
    (0xD7, 0xAF, 0x5F),
    (0xD7, 0xAF, 0x87),
    (0xD7, 0xAF, 0xAF),
    (0xD7, 0xAF, 0xD7),
    (0xD7, 0xAF, 0xFF),
    (0xD7, 0xD7, 0x00),
    (0xD7, 0xD7, 0x5F),
    (0xD7, 0xD7, 0x87),
    (0xD7, 0xD7, 0xAF),
    (0xD7, 0xD7, 0xD7),
    (0xD7, 0xD7, 0xFF),
    (0xD7, 0xFF, 0x00),
    (0xD7, 0xFF, 0x5F),
    (0xD7, 0xFF, 0x87),
    (0xD7, 0xFF, 0xAF),
    (0xD7, 0xFF, 0xD7),
    (0xD7, 0xFF, 0xFF),
    (0xFF, 0x00, 0x00),
    (0xFF, 0x00, 0x5F),
    (0xFF, 0x00, 0x87),
    (0xFF, 0x00, 0xAF),
    (0xFF, 0x00, 0xD7),
    (0xFF, 0x00, 0xFF),
    (0xFF, 0x5F, 0x00),
    (0xFF, 0x5F, 0x5F),
    (0xFF, 0x5F, 0x87),
    (0xFF, 0x5F, 0xAF),
    (0xFF, 0x5F, 0xD7),
    (0xFF, 0x5F, 0xFF),
    (0xFF, 0x87, 0x00),
    (0xFF, 0x87, 0x5F),
    (0xFF, 0x87, 0x87),
    (0xFF, 0x87, 0xAF),
    (0xFF, 0x87, 0xD7),
    (0xFF, 0x87, 0xFF),
    (0xFF, 0xAF, 0x00),
    (0xFF, 0xAF, 0x5F),
    (0xFF, 0xAF, 0x87),
    (0xFF, 0xAF, 0xAF),
    (0xFF, 0xAF, 0xD7),
    (0xFF, 0xAF, 0xFF),
    (0xFF, 0xD7, 0x00),
    (0xFF, 0xD7, 0x5F),
    (0xFF, 0xD7, 0x87),
    (0xFF, 0xD7, 0xAF),
    (0xFF, 0xD7, 0xD7),
    (0xFF, 0xD7, 0xFF),
    (0xFF, 0xFF, 0x00),
    (0xFF, 0xFF, 0x5F),
    (0xFF, 0xFF, 0x87),
    (0xFF, 0xFF, 0xAF),
    (0xFF, 0xFF, 0xD7),
    (0xFF, 0xFF, 0xFF),
    (0x08, 0x08, 0x08),
    (0x12, 0x12, 0x12),
    (0x1C, 0x1C, 0x1C),
    (0x26, 0x26, 0x26),
    (0x30, 0x30, 0x30),
    (0x3A, 0x3A, 0x3A),
    (0x44, 0x44, 0x44),
    (0x4E, 0x4E, 0x4E),
    (0x58, 0x58, 0x58),
    (0x62, 0x62, 0x62),
    (0x6C, 0x6C, 0x6C),
    (0x76, 0x76, 0x76),
    (0x80, 0x80, 0x80),
    (0x8A, 0x8A, 0x8A),
    (0x94, 0x94, 0x94),
    (0x9E, 0x9E, 0x9E),
    (0xA8, 0xA8, 0xA8),
    (0xB2, 0xB2, 0xB2),
    (0xBC, 0xBC, 0xBC),
    (0xC6, 0xC6, 0xC6),
    (0xD0, 0xD0, 0xD0),
    (0xDA, 0xDA, 0xDA),
    (0xE4, 0xE4, 0xE4),
    (0xEE, 0xEE, 0xEE),
];


#[cfg(test)]
mod tests {
    use super::TermColor;

    #[test]
    fn quadrance_equal() {
        let f1 = TermColor::from(0,0,0);
        let f2 = TermColor::from(0,0,0);

        assert_eq!(f1.quadrance(&f2), 0.0);
    }

    #[test]
    fn quadrance_non_equal() {
        let f1 = TermColor::from(0,0,0);
        let f2 = TermColor::from(70, 120, 200);

        assert_ne!(f1.quadrance(&f2), 0.0);
    }
    
    #[test]
    fn quadrance_opposite() {
        let f1 = TermColor::from(0,0,0);
        let f2 = TermColor::from(255,255,255);

        assert_eq!(f1.quadrance(&f2), super::MAX_QUADRANCE);
    }

    #[test]
    fn quadrance_size_comparison() {
        let f1 = TermColor::from(0,0,0);
        let f2 = TermColor::from(255,255,255);
        let f3 = TermColor::from(127,127,127);

        let q1 = f1.quadrance(&f2);
        /* More similar colors, hence smaller value */
        let q2 = f1.quadrance(&f3);

        assert!(q1-q2 > 0.0);
    }
}
